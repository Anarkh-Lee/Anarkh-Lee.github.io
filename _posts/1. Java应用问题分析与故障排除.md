## 1. Java应用问题分析与故障排除

### 1.1 性能瓶颈分析

**1.常见的性能陷阱**

* 1.常见的性能现象：
  * 1.无响应
  * 2.运行缓慢
* 2.导致现象的问题：
  * 1.不良架构
  * 2.不恰当的线程同步
  * 3.资源争用
  * 4.不恰当的虚拟机参数
  * 5.缓慢的磁盘和网络IO
  * 6.内存泄露

**2.性能设计和调优的原则**

* 三个原则

  * 80-20原则

    20%的代码消耗了80%的资源，20%的代码消耗了80%的时间

  * 动态原则

    瓶颈是动态的，不同的使用条件瓶颈可能不同

  * 分级原则

    只有解决了当前的瓶颈，下一个瓶颈有可能出现

* 系统上线前理想的步骤：

  压力测试-->瓶颈分析-->优化调整-->回归验证

**3.问题源头**

* 部署问题
  * 不合理的负载分配
  * 通信效率低下
    * 网速慢，带宽不够
    * 发的数据包过大，解析起来过慢
  * 参数配置不当（连接池、线程池、JVM等）
  * 日志级别（有可能引起太高的磁盘IO，引起系统缓慢）
* 设计问题
  * 同步/异步使用不当
  * 缺乏必要的缓冲设计
  * 并发设计不当--资源争用
* 编码问题
  * 过大的同步范围
    * 事务过大需要拆成小事务
  * 效率低下的SQL语句
    * 比如没有建索引等
  * 全局集合对象
    * 把大量的对象都放到全局集合中，导致内存越来越大，而gc无法回收全集集合这些对象，久而久之，就会导致内存溢出，导致系统宕机。
  * 非线程同步设计问题
    * 编码时锁住了大量对象，而这些对象没有被释放，导致线程死锁，甚至有些代码中出现死循环。
  * String+

### 1.2 线程堆栈分析

**1.线程堆栈分析介绍**

* 1.概念

  线程堆栈也称作线程调用的堆栈，是虚拟机运行的时候线程状态的一个瞬间的快照。它采用了文本的方式记录了系统在某一时刻所有线程的运行状态；包括每一个线程的调用堆栈，和锁的所持有情况。

  不同的虚拟机打印出来的格式稍有不同，但是线程堆栈的信息大同小异，包括线程的名字，线程的id，线程的数量，线程的运行状态，锁的状态，还有线程调用堆栈的情况（包括执行的方法，执行源代码的行数）。

* 2.技术原理

  通过分析JVM线程运行情况，定位性能问题。

* 3.解决问题

  * 资源争用
  * 业务死锁
  * 系统挂起没有响应
  * CPU资源过高

* 4.使用场景

  识别高负载条件的性能瓶颈

* 5.不适用场合

  但操作时耗时，如一次点击，感觉迟缓

**2.如何输出线程堆栈**

* 输出堆栈的3种方法

  * Windows：在运行JAVA的控制台上按ctrl+break组合键

  * Unix：使用Kill -3 <javapid>输出到启动的java控制台或日志

  * 在jdk安装的bin目录下有两个程序jps和jstack（jstack <pid> >>filename）

    ![](F:\myNewBlob\Anarkh-Lee.github.io\_posts\img\jps_jstack.png)

* 得到了线程堆栈，主要分析要点
  * 线程死锁
  * CPU过高
  * 资源不足
  * 性能缓慢
  * 异常退出

**3.线程状态**

![](.\img\线程状态.png)

* Runnable：从虚拟机的角度看，Runnable状态代表线程正处于运行状态。通常情况下，处于运行状态下都会消耗cpu，但不是所有的Runnable状态都会消耗cpu，比如线程正在进行网络I/O的时候，这时，线程的状态是挂起的，不会调用java的sleep()或者wait()这些方法导致线程进入waiting状态，只有大量数据要进行处理时，才会消耗cpu。

* 死锁，Deadlock（重点关注）

* 执行中，Runnable

* 等待资源，Waiting on condition（重点关注）

  表示这个线程正在等待另外一个条件的发生来把自己唤醒，或者调用了sleep()，如果大量的线程处于Waiting on condition状态，很可能是这些线程都正在获取第三方资源（第三方网络资源、第三方数据库连接资源），但是迟迟获取不到应答，导致这些线程进入了等待状态。

* 等待获取监视器，Waiting on monitor entry（重点关注）

  线程正在执行Object.wait()方法。只有当线程获得了monitor，如果发现线程继续运行的条件没有满足，就调用Object.wait()方法，放弃了monitor。一般这种线程都是rmi相关线程或者是gc的线程，这种一般不是故障发生的点。

* 暂停，Suspended

* 对象等待中，Object.wait()或TIMED_WAITING

* 阻塞，Blocked（重点关注）

  等待进入了一个临界区。如果大量的线程处于了Blocked状态，而且还有waiting on monitor entry这种字样，就很可能是一个全局锁，锁住了大量的线程，也就是通常说的线程锁。

  介绍一下死锁：多个线程都在争夺同一个资源，这种情况下，JVM通常会自己检测出来。在现象上：卡住了、空白页、线程挂起。

* 停止挂起，Parked

**4.线程堆栈解读**

![](.\img\线程堆栈分析.png)

解读如下：

* 线程T1和T2均在等待资源状态（waiting for monitor entry）发生了线程阻塞。

* T2运行在DeadLock.java的第40行，在等待<0x22a297a8>对象释放锁，并锁定了<0x22a297b0>对象。

* T1运行在DeadLock.java的第25行，在等待<0x22a297b0>对象释放锁，并锁住了<0x22a297a8>对象。

  由上述解读，可以确定代码发生了线程死锁，并可以确定产生了死锁的代码行数。

### 1.3 内存溢出分析

内存溢出分为两种情况：

* 发生了内存泄露
* 虽然没有发生内存泄露，但是内存使用的增长太快了，比java虚拟机回收的速度还要快，这样也会导致内存不够用。

**1.内存溢出分析-介绍**

**1.1分析方法**

* 通过观察对象的数据和分配的位置，找到大量占用内存的对象。

**1.2发生现象**

* 长时间运行后无法提供服务
* JVM宕机（Core Dump）

**1.3解决方案**

* 全局集合-避免把临时对象放入全局集合
* 缓存-不用的对象及时清理
* Runnable对象生成后要及时使用，避免产生太多的线程

**2.内存溢出分析-原理**

内存泄露和内存溢出的关系：

只有内存泄露达到一定程度才会引起内存溢出。

内存溢出是如何产生的？

编写程序当中，编写到了一些代码，这些代码使用对象的时候，放入到了java虚拟机内存回收无法回收的区域，而这种代码被调用的次数又很多，那么就会导致越来越多的java虚拟机内存没有办法被它的回收器回收，这样内存的占用就越来越大，直到内存装不下这些对象，就会产生内存溢出，应用就无法工作，产生宕机。此时在JVM的安装目录下还会产生大量的Core Dump文件。

**2.1如何产生**

* 系统中存在越来越多的无用对象和根对象之间存在引用关系
* 对象产生过快
* 内存泄露产生了

**2.2如何消除**

* 截断系统中无用对象和根对象之间的引用关系
* 控制大对象产生的速度
* JVM可正常回收它们

**2.3常见原因**

* 对象存入全局HashMap，用完没有及时remove掉
* Thread只new了，但没有start
* 产生对象太大，内存装不下
* ...











**1.内存溢出分析-确认**

**1.1观察现象**

![](.\img\内存溢出分析现象.png)

* 应用程序无法运行
* 应用日志出现OutOfMemoryError
* JRE或应用程序路径出现大量的heap dump和Core Dump文件。

**1.2测试方法**

![](.\img\内存溢出现象测试方法FullGC.png)

* 多次执行Full GC操作
* 每次Full GC后，JVM的已使用内存比上次越来越多

