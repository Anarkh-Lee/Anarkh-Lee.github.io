## 1. Java应用问题分析与故障排除

### 1.1 性能瓶颈分析

**1.常见的性能陷阱**

* 1.常见的性能现象：
  * 1.无响应
  * 2.运行缓慢
* 2.导致现象的问题：
  * 1.不良架构
  * 2.不恰当的线程同步
  * 3.资源争用
  * 4.不恰当的虚拟机参数
  * 5.缓慢的磁盘和网络IO
  * 6.内存泄露

**2.性能设计和调优的原则**

* 三个原则

  * 80-20原则

    20%的代码消耗了80%的资源，20%的代码消耗了80%的时间

  * 动态原则

    瓶颈是动态的，不同的使用条件瓶颈可能不同

  * 分级原则

    只有解决了当前的瓶颈，下一个瓶颈有可能出现

* 系统上线前理想的步骤：

  压力测试-->瓶颈分析-->优化调整-->回归验证

**3.问题源头**

* 部署问题
  * 不合理的负载分配
  * 通信效率低下
    * 网速慢，带宽不够
    * 发的数据包过大，解析起来过慢
  * 参数配置不当（连接池、线程池、JVM等）
  * 日志级别（有可能引起太高的磁盘IO，引起系统缓慢）
* 设计问题
  * 同步/异步使用不当
  * 缺乏必要的缓冲设计
  * 并发设计不当--资源争用
* 编码问题
  * 过大的同步范围
    * 事务过大需要拆成小事务
  * 效率低下的SQL语句
    * 比如没有建索引等
  * 全局集合对象
    * 把大量的对象都放到全局集合中，导致内存越来越大，而gc无法回收全集集合这些对象，久而久之，就会导致内存溢出，导致系统宕机。
  * 非线程同步设计问题
    * 编码时锁住了大量对象，而这些对象没有被释放，导致线程死锁，甚至有些代码中出现死循环。
  * String+

### 1.2 线程堆栈分析

**1.线程堆栈分析介绍**

* 1.概念

  线程堆栈也称作线程调用的堆栈，是虚拟机运行的时候线程状态的一个瞬间的快照。它采用了文本的方式记录了系统在某一时刻所有线程的运行状态；包括每一个线程的调用堆栈，和锁的所持有情况。

  不同的虚拟机打印出来的格式稍有不同，但是线程堆栈的信息大同小异，包括线程的名字，线程的id，线程的数量，线程的运行状态，锁的状态，还有线程调用堆栈的情况（包括执行的方法，执行源代码的行数）。

* 2.技术原理

  通过分析JVM线程运行情况，定位性能问题。

* 3.解决问题

  * 资源争用
  * 业务死锁
  * 系统挂起没有响应
  * CPU资源过高

* 4.使用场景

  识别高负载条件的性能瓶颈

* 5.不适用场合

  但操作时耗时，如一次点击，感觉迟缓

**2.如何输出线程堆栈**

* 输出堆栈的3种方法

  * Windows：在运行JAVA的控制台上按ctrl+break组合键

  * Unix：使用Kill -3 <javapid>输出到启动的java控制台或日志

  * 在jdk安装的bin目录下有两个程序jps和jstack（jstack <pid> >>filename）

    ![](.\img\jps_jstack.png)

* 得到了线程堆栈，主要分析要点
  * 线程死锁
  * CPU过高
  * 资源不足
  * 性能缓慢
  * 异常退出

**3.线程状态**

![](.\img\线程状态.png)

* Runnable：从虚拟机的角度看，Runnable状态代表线程正处于运行状态。通常情况下，处于运行状态下都会消耗cpu，但不是所有的Runnable状态都会消耗cpu，比如线程正在进行网络I/O的时候，这时，线程的状态是挂起的，不会调用java的sleep()或者wait()这些方法导致线程进入waiting状态，只有大量数据要进行处理时，才会消耗cpu。

* 死锁，Deadlock（重点关注）

* 执行中，Runnable

* 等待资源，Waiting on condition（重点关注）

  表示这个线程正在等待另外一个条件的发生来把自己唤醒，或者调用了sleep()，如果大量的线程处于Waiting on condition状态，很可能是这些线程都正在获取第三方资源（第三方网络资源、第三方数据库连接资源），但是迟迟获取不到应答，导致这些线程进入了等待状态。

* 等待获取监视器，Waiting on monitor entry（重点关注）

  线程正在执行Object.wait()方法。只有当线程获得了monitor，如果发现线程继续运行的条件没有满足，就调用Object.wait()方法，放弃了monitor。一般这种线程都是rmi相关线程或者是gc的线程，这种一般不是故障发生的点。

* 暂停，Suspended

* 对象等待中，Object.wait()或TIMED_WAITING

* 阻塞，Blocked（重点关注）

  等待进入了一个临界区。如果大量的线程处于了Blocked状态，而且还有waiting on monitor entry这种字样，就很可能是一个全局锁，锁住了大量的线程，也就是通常说的线程锁。

  介绍一下死锁：多个线程都在争夺同一个资源，这种情况下，JVM通常会自己检测出来。在现象上：卡住了、空白页、线程挂起。

* 停止挂起，Parked

**4.线程堆栈解读**

![](.\img\线程堆栈分析.png)

解读如下：

* 线程T1和T2均在等待资源状态（waiting for monitor entry）发生了线程阻塞。

* T2运行在DeadLock.java的第40行，在等待<0x22a297a8>对象释放锁，并锁定了<0x22a297b0>对象。

* T1运行在DeadLock.java的第25行，在等待<0x22a297b0>对象释放锁，并锁住了<0x22a297a8>对象。

  由上述解读，可以确定代码发生了线程死锁，并可以确定产生了死锁的代码行数。

### 1.3 内存溢出分析

内存溢出分为两种情况：

* 发生了内存泄露
* 虽然没有发生内存泄露，但是内存使用的增长太快了，比java虚拟机回收的速度还要快，这样也会导致内存不够用。

**1.内存溢出分析-介绍**

**1.1分析方法**

* 通过观察对象的数据和分配的位置，找到大量占用内存的对象。

**1.2发生现象**

* 长时间运行后无法提供服务
* JVM宕机（Core Dump）

**1.3解决方案**

* 全局集合-避免把临时对象放入全局集合
* 缓存-不用的对象及时清理
* Runnable对象生成后要及时使用，避免产生太多的线程

**2.内存溢出分析-原理**

内存泄露和内存溢出的关系：

只有内存泄露达到一定程度才会引起内存溢出。

内存溢出是如何产生的？

编写程序当中，编写到了一些代码，这些代码使用对象的时候，放入到了java虚拟机内存回收无法回收的区域，而这种代码被调用的次数又很多，那么就会导致越来越多的java虚拟机内存没有办法被它的回收器回收，这样内存的占用就越来越大，直到内存装不下这些对象，就会产生内存溢出，应用就无法工作，产生宕机。此时在JVM的安装目录下还会产生大量的Core Dump文件。

**2.1如何产生**

* 系统中存在越来越多的无用对象和根对象之间存在引用关系
* 对象产生过快
* 内存泄露产生了

**2.2如何消除**

* 截断系统中无用对象和根对象之间的引用关系
* 控制大对象产生的速度
* JVM可正常回收它们

**2.3常见原因**

* 对象存入全局HashMap，用完没有及时remove掉
* Thread只new了，但没有start
* 产生对象太大，内存装不下
* ...

**3.内存溢出分析-确认**

**3.1观察现象**

![](.\img\内存溢出分析现象.png)

* 应用程序无法运行
* 应用日志出现OutOfMemoryError
* JRE或应用程序路径出现大量的heap dump和Core Dump文件。

**3.2测试方法**

![](.\img\内存溢出现象测试方法FullGC.png)

* 多次执行Full GC操作
* 每次Full GC后，JVM的已使用内存比上次越来越多

能否在系统运行时检测出系统是否有内存溢出的可能性呢？

系统运行时可以每隔一段时间做一次Full GC操作（Full GC操作可能会导致用户使用系统时卡一下，应该在用户使用比较少的时候做），多次运行Full GC操作之后呢，看是不是每次Full GC之后，JVM的已使用内存比上次的越来越多，越来越多就代表有一部分对象在Full GC当中没有被清理掉，这种现象就有可能出现内存泄漏，导致内存溢出。

**4.内存溢出分析-定位**

* 1.在系统运行平稳后，做一次垃圾回收，并进行标记；

* 2.反复进行可能出现内存泄漏的操作，然后再进行一次垃圾回收；

* 3.观察并记录哪些对象是增加的最多的；

* 4.重复进行上面的操作，找出一直是增加的对象；这些对象可能是导致内存泄漏的原因；

* 5.通过工具的下钻打开一直增加的对象，将显示这些对象是由哪些类创建的。

  ![](.\img\内存溢出分析-定位1.png)

  ![](.\img\内存溢出分析-定位2.png)

### 1.4 常用工具使用

**常用工具使用-JVM工具**

* 命令行工具
  * Jstat（关注GC的次数和GC消耗时间）
  * Jmap（获取内存镜像）
  * HeapAnalyzer（内存分析工具，定位内存当中哪些对象占用最多，这是对象是由哪些类创建出来的，从而定位代码）
* 图形化工具
  * JVisualVM
  * Jconsole

**1.4.1常用工具使用--jstat**

工具都在jvm安装目录的bin目录下

![](.\img\jstat.png)

从上图中可以计算得到如下值：

1.年青代GC发生了1989次（YGCT）,共耗费了41.001秒（YGC），故年青代每次GC的时间为：41.001/1989=0.020秒。

2.完全GC发生了1次（FGCT），共耗费了0.971秒（FGC），故完全GC每次GC的时间为：0.971/1=0.971秒。

一般性能较好的判断：YGC耗时在50-100ms以内，FGC小于1秒以内。

如果GC非常频繁，不管是YGC还是FGC，都要关注内存对象产生的是不是过快了。

**1.4.2常用JVM工具--jmap**

```
jmap -dump: format=b, file=testjvm.dump $vmid$
```

vmid是java应用的进程id号，file: java:堆内存数据保存为文件的名称。

以上的命令可以将当前JAVA内存堆保存为文件，便于进一步进行分析。

特别注意：

jmap会把整个内存的镜像存到硬盘上，会在很短的时间内向硬盘写入大量内容。进行此工作的时候，应用访问可能会中断。所以不应该在业务运行状态下操作此命令。

**1.4.3常用工具使用--HeapAnalyer**

通过jmap得到了堆运行镜像文件之后，可以使用HeapAnalyer工具来进行内存镜像的分析。

![](.\img\HeapAnalyer.png)

命令行：

```
java -Xmx800m -jar ha395.jar
```

注意：-Xmn800m是指定工具所需的java堆大小，此值要大于分析文件的尺寸大小，如果启动过程中发现控制台有java.lang.OutOfMeemoryError出现，可以适当加大上面的数字800，给予更多的空间。ha395.jar中的文件名称按实际下载解压后的文件名为准。

**1.4.4常用工具使用--JVisualVM**

![](.\img\JVisualVM.png)

JDK1.6以后提供（之前可以使用Jconsole）

如果是远程的机器没有图形界面，我们也想监控它的JVM内存或者用图形化监控它的参数，在运行情况需要怎么办？

可以按照下面方法配置一个JAVA_OPTS参数，然后启动它的jmxremote.rmi远程调用这种方式，就可以连接上远程的JVM，实时观察现象。

配置方法：

应用启动参数增加

```
JAVA_OPTS="-

Djava.rmi.server.hostname=127.0.0.1 -

Dcom.sun.management.jmxremote.port=80

99 -

Dcom.sun.management.jmxremote.rmi.port

=8099 -

Dcom.sun.management.jmxremote.ssl=false

-

Dcom.sun.management.jmxremote.authenti

cate=false"
```

### 1.5 故障排除案例

**1.5.1故障排除案例--CPU占用率高**

![](.\img\CPU占用率高.png)

* 1.问题表现

  某系统上线前部署后，在没有访问压力的情况下，启动后即出现单位CPU资源占满，几天后无法访问。

* 2.问题分析

  上述现象一般是系统中出现了类似死循环的业务逻辑且长时间运行所致，应找到其对应的运行进程，如果可能，应进一步找到其执行代码。

* 3.排查步骤

  * 使用TOP命令查看，发现进程号为17733的java进程占满多个CPU资源
  * 对进程执行`top -H -p`进行细分查看发现nid为17772和18156的子进程占满单个CPU资源
  * 将占用CPU的17772和18156进程号转为16进制数，分别为46ec和456c
  * 在TheadDump中查找进程中运行的方法
  * 找到运行的方法对应代码行，交给开发人员排查代码

* 4.解决效果

  代码中出现死循环业务逻辑，且该段代码未做控制，随时间推移导致多个CPU资源占满，系统无法运行。经现场开发人员修改系统代码后。此问题不再出现。

**1.5.2故障排除案例--运行缓慢**

![运行缓慢](.\img\运行缓慢.png)

* 1.问题表现

  某系统与其上线后将有大量用户访问，性能测试登录后200用户同时登录响应时间达到了20秒，不满足性能要求。

* 2.问题分析

  应用和数据库服务器硬件资源占用很低，从应用方面进行性能瓶颈跟踪。

* 3.排查步骤

  * 捕获线程堆栈后，发现大量的线程处于阻塞，其执行为等待获得数据库连接池中的连接。对应用系统数据库连接参数进行调整后，业务响应时间下降到8秒，但仍未满足业务需求（响应时间3秒内）。
  * 重新采集线程dump查看线程发现线程阻塞问题消失，查看调用方法，大部分线程都在做取redis内容的操作。通过逐个对Redis对象存取排查，发现从redis获取组织和权限树时存取缓慢。组织和权限是一个4层的树形数据结构。大小超过1M，每次存取Redis都要序列化和反序列化，生成对象效率很低。
  * 考虑如果树对象的修改很少，每次修改时向redis存入时间戳，取时先比较时间戳，发生变化时再重取对象，可以大幅减少树对象获取次数。

* 4.解决效果

  经过上述调优步骤，登录并方位首页在200用户同时访问时响应时间下降到0.5秒，满足系统预期要求。

**1.5.3故障排除案例--系统无响应**

![](.\img\系统无响应.png)

* 1.问题表现

  某系统正式上线运行以来，应用服务器偶尔会出现宕机故障，导致宕机的Server节点失去响应。

* 2.问题分析

  查看应用相关日志，没有发现明显的异常情况，查看故障发生时应用中间件JVM截图，有大量GC活动和长时间CPU占用，怀疑出现内存不足。

* 3.排查步骤

  * 采集Java Thread Dump，采集方法每隔5秒左右执行一次，共采集了9次
  * 在9次Thread Dump中，有一个线程持续运行一个业务方法。编号为ExecuteThread：'9'的线程持续运行32秒没有完成
  * 运行的业务方法中使用额JDBC的ScrollableResultSet对象，可滚动的结果集需要在JVM内存中缓存数据对象，因此当查询最后一页的数据时，不仅需要遍历全部的查询结果还需要缓存全部的查询结果，因此当查询的数据量过大时，对中间件的CPU和JVM内存占用都非常大，使得业务系统失去响应，而且有使JVM发生内存溢出OOM错误的风险。

* 4.解决效果

  将USE_OPTIMIZE_PAGING_SQL参数修改为true，使用数据库翻页，页面响应时间大大缩短，在翻页操作的执行过程中，业务系统其它功能可以正常使用，故障解决。

**1.5.4故障排除案例--内存溢出**

![](.\img\内存溢出.png)

* 1.问题表现

  某在线学习系统项目按合同的要求有Tomcat环境迁移至WAS环境后，在用户使用（无并发）过程中多次出现应用服务器宕机导致项目无法顺利验收

* 2.问题分析

  通过查看服务日导，发现WAS的Profiles目录下已存在大量的javacore和heapdump文件。系统发生了JVM内存溢出导致应用服务器重启

* 3.排查步骤

  * 设置JVM堆最大值为1024m，启动后系统占用JVM堆内存约为600M，分别播放一个200M课件和一个700M课件，使用工具监控JVM内存使用情况。
  * 下载完200课件后，系统可以正常访问，JVM堆使用增加200M
  * 下载700M课件过程中，系统发生内存溢出，应用服务器无法访问，JVM工具无法进行监控。
  * 由上述现象分析，WAS在用户下载课件文件时，尝试将整个课件文件全部调入JVM后再推送给用户，导致JVM内存溢出。
  * 经查相关文档，确认WAS下载大文件时，会将文件读取到jvm，导致jvm发生内存溢出现象。

* 4.解决效果

  对于WAS曾出现过内存溢出，并且存在文件下载情况的，建议设置一下参数：应用程序服务器->server1->web容器->定制属性，输入"com.ibm.ws.webcontainer.channelwritetype"值"sync"

  按上述步骤设置该参数后。同时下载4个700M课件，系统JVM堆大小无明显增长，系统正常访问，问题得以解决。



## 2.MySQL架构设计与管理

### 2.1 集群架构概念原理

**2.1.1 集群架构概念原理**

利用至少两台或者多台数据库服务器，构成一个虚拟单一数据库逻辑映像，像单数据库系统那样，向客户端提供透明的数据服务。

（1）采用数据库集群的主要目的：

* Fault tolerance

  数据的可靠性、服务的可用性

* Load balancing

  性能的提升

（2）根据数据的共享方式不同，可以将数据库集群分为Share disk架构（下左图）和Share Nothing架构（下右图）

* Share disk架构是通过多个服务器节点共享一个存储来实现数据库集群，典型的产品：Oracle RAC
* Share Nothing通常就是分布式的架构，将数据库中的数据按照某一标准分布到多台机器中，查询或插入时按照条件查询或者插入对应的分区；另一种是每一个节点完全独立，节点之间通过网络连接，数据完全相同。对于MySQL集群来说，主要应用的是Share Nothing架构。

![](.\img\Mysql集群.png)

（3）数据库的集群包括两（三）个层面的含义：

* 1.数据的存储能力
* 2.数据的处理能力（也就是计算能力）
* 3.系统的高可用性

（4）什么时候需要采用数据库集群呢？

* 通常来说，单点数据库不能支持业务发展了（1.性能遇到问题，比如吞吐量、响应时间不能满足业务需求；2.单点数据库的数据存储不下了）。

（5）三个重要概念

* ACID（对于单点数据库系统都是满足ACID原理）
  * Atomicity（原子性）
  * Consistency（一致性）
  * Isolation（隔离性）
  * Durability（持久性）
* CAP（在一个分布式系统中，一致性、可用性、分区容忍性这三点通常不可能都能全部具备）
  * Consistency（一致性【在分布式系统中，所有的数据备份，在同一时刻是否有同样的值，即所有的节点访问同一份最新的数据副本】）
  * Availability（可用性【在集群中一部分节点故障后，集群整体是否还能向客户端响应读写请求，即对于数据更新是否具备高可用性】）
  * Partition tolerance（分区容忍性【对通信的时限要求，系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前的情况就C和A之间做出选择，关系型数据库通常选择C与A】）
* BASE（对CAP中的一致性和可用性权衡的结果。其核心思想：及时无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方法使系统达到最终的一致性）
  * Basically Available（基本可用）
  * Soft state（软状态）
  * Eventually consistent（最终一致性）

### 2.2 集群架构设计

* **1.单实例**

  ![](.\img\单实例.png)

  局限：

  * 数据总量超出一个实例承载范围（一台机器硬盘放不下）
  * 索引大小超出一个实例承载范围（一台机器内存放不下）
    * 注：对于MySQL而言，MySQL里面所有的索引都需要加载到内存当中
  * 并发访问负载超出一个实例承载范围（一台机器撑不住）

对于集群的架构设计，通常来说，有两种方式（技术）来做集群架构的设计：垂直拆分和水平拆分

* **2.垂直拆分**

  专库专用，一个数据库由很多表构成，而每个表对应着不同的业务。垂直拆分是指按照业务对表进行分类，分不到不同的数据库上面，这样就将压力分布到不同的库上面了。

  ![](.\img\垂直拆分.png)

  优点：

  * 拆分后，业务清晰，拆分规则明确
  * 系统之间的整合和扩展容易
  * 数据维护简单

  缺点：

  * 部分的业务，业务表无法照应，只能通过接口方式解决，提高了系统的复杂度
  * 受每种业务不同的限制，存在单库性能的瓶颈，不易将数据扩展或性能提高
  * 事务的处理比较复杂

  局限：

  * 面对复杂应用无法进行拆分
  * 拆分后仍然面临单实例模式面临的各种问题

* **3.数据路由（水平拆分）**

  垂直拆分后仍然会面临单机的瓶颈，这时可以使用水平拆分。
  
  垂直拆分和水平拆分的区别：
  
  * 垂直拆分是把不同的表拆到不同的数据库中；而水平拆分是把同一个表拆到不同的数据库中。相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某个规则来分散到多个库中，每个表中包含一部分数据。简单来说，我们可以将数据的水平拆分理解为是按照数据的行进行拆分，就是将表中的某些行拆分到一个数据库，而另外的某些行拆分到其他的数据库中。
  
  水平拆分分为：
  
  * 分表
  * 分库
  
  ![](.\img\水平拆分.png)
  
  优点：
  
  * 不存在单库大数据高并发的性能瓶颈
  * 对应用透明，应用端改造较少
  * 按照合理的拆分规则拆分，join操作，基本避免了跨库join
  * 提高了系统的稳定性和负载能力
  
  缺点：
  
  * 拆分规则难以抽象
  * 分片事务一致性难以解决
  * 数据多次扩展难度跟维护量极大
  * 跨库join性能较差
  
  局限：
  
  * 复杂应用拆分困难，业务耦合性强，应用侵入大
  * 跨分片复杂操作不够成熟
  
  **拆分处理的难点--垂直拆分和水平拆分的共同缺点：**
  
  * 引入分布式事务的问题
  * 跨节点Join的问题
  * 跨节点合并排序分页问题
  
  **拆分原则**
  
  * 尽量不拆分，架构是进化而来，不是一蹴而就。（SOA）
  * 最大可能的找到最合适的切分维度
  * 由于数据库中间件对数据join实现的优劣难以把握，而且实现高性能难道极大，业务读取尽量少使用多表join，尽量通过数据冗余、分组避免数据数据跨库多表join
  * 尽量避免分布式事务
  * 单表拆分到数据1000万以内
  
* **4.主从架构**

  主从架构是指任何的一个数据库实例主节点和从节点的数据是完全一致的。

  满足高可用性，对于数据量不是很大的可以采用这种架构。

  ![](.\img\主从架构.png)

  局限：

  * 全冗余架构，A、B问题仍然存在
  * Master单点，面临性能与可用性的问题
  * 数据复制存在延迟，无法保证严格的一致性

* **5.多主架构**

  多主架构每一个节点都是一个全集，唯一不同的，主从架构是主能够接收的是读写请求，而从只能读；而多主架构每一个节点都可以进行读写请求。

  满足高可用性，对于数据量不是很大的可以采用这种架构。

  ![](.\img\多主架构.png)

  局限：

  * 全冗余架构，A、B问题仍然存在
  * 数据实时同步，并发写存在性能问题

### 2.3 MySQL复制技术

**2.3.1MySQL复制技术-binlog**

MySQL复制技术依赖于MySQL的binlog日志，记录了所有的DDL和DML相关的语句，并且以事件的形式记录，binlog日志是事务安全的。一般来说，开启了binlog日志，系统会有少许的损耗。

* 解释：
  * 以一种更有效的格式，并且是事务安全的方式包含更新日志中可用的所有信息。
  * 包含了所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。
  * 关于每个更新数据库的语句的执行时间信息。它不包含没有修改任何数据的语句。如果你想要记录所有语句（例如，为了识别有问题的查询），你应使用一般查询日志。
  * 格式分为三种类型：statement（sql语句形式记录）、mixed（混合了statement和row的优点）、row（以行的形式记录）

* 作用：
  * 类似于Oracle的归档日志，可以用来查看数据库的变更历史（具体的时间点所有的SQL操作）
  * 数据库增量备份和恢复（增量备份和基于时间点的恢复）
  * MySQL的复制（主主数据库的复制、主从数据库的复制）

**基本概念**

* Master：主节点
* Slave：从节点
* Binlog：基于主节点上数据的变更都会记录到这个日志中
* Relaylog：从节点从主节点拉过来的二进制日志会记录在从节点的Relaylog日志中

**MySQL主库Replication模块：**

* Binlog Dump：读取主库上的二进制日志当中的事件，并发送给从库的IO线程。如果主库没有更新信息，该线程就会进入休眠。
* Binlog Filter：根据配置信息（比如：binlog_do_db或binlog_ignore_db）做Binlog的过滤的。

**MySQL备库Replication模块：**

* IO_THREAD：把主库上的Dump线程转过来的Binlog日志进行接收，并写到Relaylog当中。

* SQL_THREAD：读取slave节点上的Relaylog，做重放。将Relaylog中的数据写到slave数据库中。

* Relaylog Filter：根据配置信息（replicate_do_db、replicate_do_table、replicate_ignore_db、replicate_ignore_table、replicate_rewrite_db、replicate_wild_do_table、replicate_wild_ignore_table）对Relaylog做过滤，什么样的数据可以存储到Relaylog上。

  ![](.\img\MySQL复制技术1.png)

**配置方式：**

在my.cnf配置文件中加入：

```
[mysqlId]
server-id = 1
log-bin = mysql-bin
binlog-do-db=***
binlog_format=row

log_slave_updates=on
expire_logs_days = 3
max_binlog_size = 1073741824
sync_binlog = 1  #0或N
binlog_cache_size = 2M
replicate-do-db=***
replicate-ignore-db=***
```

**2.3.2四种复制模式**

* 异步复制（Asynchronous Replication）

  MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返回给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。

* 半同步复制（Semisynchronous Replication）

  介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟至少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。

* 全同步复制（Fully synchronous replication）

  指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会受到严重的影响。

* 组复制（Group Replication）

  组复制，提供了多写（multi-master update）的特性，增强了原有的mysql的高可用架构，支持单主模式和多主模式。2016-12-12日5.7.17正式推出组复制。

**2.3.2.1异步复制**

![](.\img\异步复制1.png)

​	![](.\img\异步复制2.png)

* 搭建复制

  搭建复制的必备条件：复制的机器之间网络通畅，Master打开了binlog。

  搭建复制步骤：

  * 1.创建账户：`GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%' IDENTIFIED BY 'XXX';`

  * 2.`SHOW MASTER STATUS;`记录下File和Position。

  * 3.在Slave上`CHANGE MASTER TO master_host= 'IP ',master_user='repl',master_password= 'xxx',master_log_file='mysql-bin.00000x',master_log_pos=pos;`

  * 4.Slave上执行`start slave`开始复制。

    ```
    ##########################
    server-id = 1
    log-bin = mysql-bin
    binlog-do-db = ***
    binlog_format = row
    ```


**2.3.2.2半同步复制**

![](.\img\半同步复制.png)

* 搭建复制

  搭建复制步骤：

  1.安装插件（主从都安装）

  ```
  mysql> INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
  mysql> INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
  mysql> show plugins;
  ```

  2.`SHOW MASTER STATUS;`记录下File和Position。

  3.在Slave上`CHANGE MASTER TO master_host= 'IP',master_user='repl',master_password= 'xxx',master_log_file='mysql-bin.00000x',master_log_pos=pos;`

  4.Slave上执行`start slave`开始复制。

* 配置参数：

  ```
  server-id = 1
  log-bin = mysql-bin
  binlog-do-db = ***
  binlog_format=row
  plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
  rpl_semi_sync_master_enabled=1	#主开启半同步复制
  rpl_semi_sync_slave_enabled=1	#从开始半同步复制
  rpl_semi_sync_master_timeout=10000
  rpl_semi_sync_master_wait_for_slave_count=1
  ```

  注：timeout=10000，意味着，如果说网络延迟比较大，10s后如果没有任何一个从节点与主节点数据保持一致，那么半同步复制就会退化为异步复制。

  事实上，半同步复制并不是严格意义上的半同步复制，如果延迟很大就会变为异步复制。

**2.3.2.3组复制**

![](.\img\组复制1.png)

![](.\img\组复制2.png)

* 特征：

  * 多写，写冲突检测（每个节点都支持写操作）
  * 良好的扩展能力，可动态增删节点，组成员自动管理（节点数最好不要超过9个）
  * 组内高可用
  * 确保组内数据最终一致性（通过分布式协议和分布式recovery机制保证）

* 单组模式下，如果组失效以后，如何做高可用性切换：

  ![](.\img\组复制单主失效高可用切换.png)

* 多主架构，任意节点失效以后，如何做高可用切换：

  ![](.\img\多主架构节点失效后高可用切换.png)

* 什么样的应用场景适合用组复制？

  * 弹性的数据库复制环境

    组复制可以灵活的增加和减少集群中的数据库实例

  * 高可用的数据库环境

    组复制允许数据库实例宕机，只要集群中大多数服务器可用，则整个数据库服务可用

  * 数据量始终，事务粒度小，交易类业务

* 组复制的限制条件：

  * 存储引擎必须为Innodb
  * 每个表必须提供主键
  * 只支持ipv4，网络需求较高
  * 一个组最多只能有9台服务器
  * 不支持Replication event checksums
  * 不支持Savepoints
  * 多主模式不支持SERIALIZABLE事务隔离级别
  * 多主模式不能完全支持级联外键约束
  * 多主模式不支持在不同节点上对同一个数据库对象并发执行DDL（在不同节点上对同一行并发进行RW事务，后发起的事务会失败）

### 2.4 MySQL集群架构方案

**2.4.1 主主方案**

两个阶段互为对方的主，互为对方的从。双向复制。这两个节点都可以做读写操作。

![](.\img\MySQL集群机构方案-主主.png)

* 双主热备是最常见的配置模式：将两个实例互相设置对方为自己的主库。
* 场景：
* 应用：
* 注意：应用访问时应做清楚的划分，避免同一个请求同时落在不同的两个实例上，这样会造成处理冲突的错误。

**2.4.2主从方案**

![](.\img\MySQL集群架构方案-主从.png)

* 一个主库接收所有的写请求
* 多个备库接收全部/大部分读请求
* 场景：适用于写少读多的应用场景
* 配置：
* 注意：

**2.4.3主从从方案**

![](.\img\MySQL集群架构方案-主从从.png)

* MySQL还可以配置出Master->Slave1->Slave2的级联复制，Master->Slave1这一步还可以配置为Master<->Slave1->Slave2，让Slave2作为双主热备的一个备库。

* 场景：
* 配置：

**2.4.4主主从方案**

![](.\img\MySQL集群架构方案-主主从.png)

* 场景：实现数据分析部门的需求，将多个系统的数据汇聚到一台服务器上进行统计分析。

* 修改参数：

  ```
  master_info_repository=TABLE;
  relay_log_info_repository=TABLE;
  slave>change master to master_host="127.0.0.1",master_port=12047,
  master_user="msandbox",master_password="msandbox" for channel="master1";
  slave>change master to master_host="127.0.0.1",master_port=12048,
  master_user="msandbox",master_password="msandbox" for channel="master2";
  slave>start slave for channel="master1";
  slave>start slave for channel="master2";
  ```

**2.4.5galera**

在MySQL组复制方案出来之前，业内一直使用的都是galera，因此galera的使用场景等都是和组复制一样的。

![](.\img\galera1.png)

![](.\img\galera2.png)

* 使用建议：
  * 1.集群节点建议最少3个，防止脑裂。
  * 2.整个集群的写入吞吐量受最弱节点的限制，保证配置均衡。
* 功能及非功能评测结论
  * 多主架构：集群中节点对等，每一个节点都可以接受读写请求。
  * 同步复制：一个节点上的写操作被并行复制到其他所有节点，无Slave Lag。
  * 事务一致性：严格的事务控制与冲突检测，保证全局事务一致性，不丢交易。
  * 自动成员控制：失效节点被自动清除，新增节点自己进行数据复制与平衡。
  * 性能方面：性能扩展性好。
* 优点：
  * 1.Active-Active架构，集群中任一节点进行数据读写；
  * 2.同步复制，保证严格的全局事务一致性；
  * 3.自动成员控制，支持动态扩展，自身实现读/写高可用；
  * 4.可实现负载均衡。
* 缺点：
  * 1.数据同步，冲突检测损耗较大；
  * 2.大事务导致延迟；
  * 3.执行DDL时带来集群锁定，逐个节点执行，维护成本高。
* 适用场景：
  * 1.交易类应用，要求严格的事务一致性；
  * 2.要求高可用、事务粒度小、DDL操作少的应用；
  * 3.数据体量适中，不需要进行水平拆分；
  * 4.并发读压力大，需要将读操作负载均衡在多个节点上。

**2.4.6MHA**

![](.\img\MHA1.png)

![](.\img\MHA2.png)

主从架构高可用性的第三方架构的实现方式，在很多生产环境中使用较多。

**2.4.7MySQL NDB Cluster**

![](.\img\MySQL-NDB-Cluster.png)

* **管理（MGM）节点**：负责管理MySQL Cluster内的其他节点，如提供配置数据、启动并停止节点、运行备份等。由于这类节点负责管理其他节点的配置，应在启动其他节点之前首先启动这类节点。MGM节点是用命令`ndb_mgmd`启动的。

* **数据节点**：用于保存Cluster的数据。数据节点的数目与副本的数目相关，是片段的倍数。数据节点使用命令`mdbd`启动的。

* **SQL节点**：用来访问Cluster数据的节点。也就是MySQL服务，可以使用`service mysqld start`启动。

* **优点**：

  * **1.通过自动分片实现高水平的写入扩展能力**

    MySQL Cluster自动将表分片（或分区）到不同节点上，使数据库可以在低成本的商用硬件上横向扩展，同时保持对应用程序完全应用透明。

  * **2.99.999%的可用性**

    凭借其分布式、无共享架构，MySQL Cluster可提供99.999%的可用性，确保了较强的故障恢复能力和在不停机的情况下执行预定维护的能力。

  * **3.SQL和NoSQL API**

    MySQL Cluster让用户可以在解决方案中整合关系数据库技术和NoSQL技术中的最佳部分，从而降低成本、风险和复杂性。

  * **4.实时性能**

    MySQL Cluster提供实时的响应事件和吞吐量，能满足最苛刻的Web、电信及企业应用程序的需求。

  * **5.具有跨地域复制功能的多站点集群**

    跨地域复制使多个集群可以分布在不同的地点，从而提高了灾难恢复能力和全球Web服务的扩展能力。

  * **6.联机扩展和模式升级**

    为支持持续运营，MySQL Cluster允许向正在进行的数据库模式中联机添加节点和更新内容，因而能支持快速变化和高度动态的负载。

* **缺点**：

  * 1.基于内存，数据库的规模受集群总内存的大小限制。
  * 2.多个节点通过网络实现通讯和数据同步、查询等操作，因此整体性受网络速度影响。
  * 3.对需要进行分片的表需要修改引擎Innodb为NDB，不需要分片的可以不修改。
  * 4.NDB的事务隔离级别只支持Read Committed，即一个事务在提交前，查询不到在事务内所做的修改；而Innodb支持所有的事务隔离级别，默认使用Repeatable Read，不存在这个问题。
  * 5.外键支持：虽然最新的Cluster版本已经支持外键，但性能有问题（因为外键所关联的记录可能在别的分片节点中），所以建议去掉所有外键。
  * 6.Data Node节点数据会被尽量放在内存中，对内存要求大。

**2.4.8Cobar方案**

不再维护

* Alibaba开源项目，Apache License 2
* 遵循MySQL协议
* Java源代码

![](.\img\MySQL-Cobar集群架构.png)

* **功能及肺功能评测结论**

  * **代理转发数据路由架构**

    Cobar作为前端代理接收请求，根据路由规则，动态解析SQL，路由到目标库中执行。

  * **数据分片**

    数据可以按照Hash方式进行自动分片，分布在不同的库之中，每个库可以是M-S架构。

  * **高可用**

    * Cobar可以自动检测数据节点的可用性，并进行准备切换；
    * Cobar节点的高可用性可以通过2中方式来实现：客户端编程、服务器负载均衡。

  * **水平扩展**

    Cobar节点与数据节点可以进行水平扩展，其中Cobar节点的扩展需要结合负载均衡来实现，数据节点的扩展需手工实现数据平衡并调整路由规则。

* **优点**：

  * 实现数据存储分布化数据访问集中化，已提供Hash路由策略，无需编程实现；
  * 支持大表拆分，小表复制；
  * 自身提供高可用性；
  * 对应用端透明，业务代码侵入较小。

* **缺点**：

  * 不支持跨库情况下的join、分页、排序、子查询操作；
  * 不支持读写分离；
  * 不支持自动化扩展。

* **适用场景**：

  * 大数据量，需要进行水平拆分，将数据分布在多个节点上；
  * 并发读/写压力大，需要进行水平拆分，将负载均衡在多个节点上；
  * 使用简单的Hash路由策略。

**2.4.9mycat方案**

社区较为活跃（http://www.mycat.io/）

![](.\img\MySQL集群架构方案-mycat.png)

### 2.5 MySQL运维管理

**2.5.1 MySQL安全注意事项**

* 不要给任何用户（除了root）访问user表的权限
* 不要使用root用户作为业务用户访问数据库
* 最小化授权原则
* drop table命令并不收回以前表的相关访问授权
* 尽量避免以root权限运行mysql，指定user=mysql
* 使用加密连接（SSL）

**2.5.2MySQL常用安全配置**

```
#设置为0，避免本地文件的非法上传
local-infile[={0|1}]
#打开后，创建用户的时候是安全创建
safe-user-create
#如果忘了数据库用户密码，可以通过这个参数临时进入数据库进行密码设置
skip-grant-tables
skip-networking
skip-show-database
```

**2.5.3 MySQL备份与恢复**

* **冷备份**：
  * MyISAM：拷贝数据目录下数据库名的目录即可，恢复只要拷贝回来即可。
  * InnoDB：拷贝全部数据目录。
* **热备份**：
  * MyISAM：Flush Tables With Read Lock;后可以直接拷贝。
  * InnoDB：xtrackaup来实现。
* **逻辑备份**：
  * mysqldump -u用户 -p密码 数据库 [表1 表2...] >db.sql
  * mysqlpump [options] > dump.sql
    * #参数-default-parallelism，默认为2
    * -parallelschemas，控制并行导出的库

**2.5.4 MySQL备份与恢复工具--Xtrabackup**

* Xtrabackup物理热备InnoDB数据：`"innobackupex --defaults-file=/tmp/other-my.cnf --user=DBUSER --password=DBUSERPASS /path/to/BACKUP-DIR/"`就可以创建一个备份，只要看到“completed OK!”就是备份成功。
* `--defaults-file`用于指定使用哪个my.cnf去找配置。
* `--user/password`指定登录MySQL的账号密码。

**增量备份**：

* `"innobackupex --incremental /data/backups --incremental-basedir=BASEDIR"`就可以创建一个增量备份。
* `-incremental-basedir`需要指定基于哪个备份去做增量备份，所以一定首先要做一次全量，才可能做增量备份。

**数据恢复**：

* Xtrabackup预处理备份数据：`"innobackupex --apply-log /path/to/BACKUP-DIR"`，Xtrabackup恢复备份数据；
* 最后将数据拷贝会InnoDB数据目录：`"innobackupex --copy-back /path/to/BACKUP-DIR"`，最后将数据拷贝会InnoDB数据目录。

**2.5.5 MySQL监控：ps-top**

* Ps-top工具是一个对MySQL监控的类似top的命令程序。该工具使用简单，兼容MySQL5.6以上版本。
* Ps-top收集performance_schema数据库中统计信息，并实时显示MySQL服务器的负载情况。
* Ps-top是使用Go语言编写的，其安装依赖Go环境。

![](.\img\MySQL监控-ps-top.png)

**2.5.6 MySQL监控优化命令**

```
--查看版本
select version();
--查看运行时间
show global status like 'uptime';	----单位秒
--查看主节点状态
show master status\G
--查看从节点状态
show slave status\G
--查看数据库中所有操作的相关状态
show global status like 'com_%' ;	----Com_insert、Com_select...
--查看数据库中查询缓存统计信息
show global status like 'qcache_%' ;	----5.7以后querycache默认关闭
--查看慢查询
show status like 'Slow_queries';
--查看表打开的信息、文件打开的信息
show status like 'open%';	----Open_tables;Opened_files
--查看join统计信息
show status like '%join%';	----Select_full_join;Select_full_range_join
--多变关联或排序时用到的临时表信息
show status like 'create_tmp%';	--Created_tmp_disk_tables;tmp_tables
--看锁等待的情况
show status like '%wait%';	--Innodb_row_lock_waits（总计等待）
--看锁等待的信息
show status like '%lock%';	--Innodb_row_lock_current_waits
--看线程的信息
show status like '%threads%';
--查看预处理语句的信息
show global status like 'com_stmt%';	--statement语句的prepare,exe,close等
```

