---
layout: post
title: '图解JVM - 17.再谈类的加载器'
subtitle: "图解JVM - 17.再谈类的加载器"
date: 2023-09-01
author: Anarkh-Lee
cover: './assets/img/banner/图解JVM.png'
tags: 图解JVM
---

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1. 概述</font>

类加载器是JVM执行类加载机制的前提。

**ClassLoader的作用：**

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1.1 类加载器的分类</font>
![]({{ '/assets/img/图解JVM/17/1类加载器的分类.png' | prepend: '' }})
![](.\img\图解JVM\17\1类加载器的分类.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Java类加载器按层次分为四类：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">引导类加载器（Bootstrap ClassLoader）</font>**
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">扩展类加载器（Extension ClassLoader）</font>**
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">应用程序类加载器（Application ClassLoader）</font>**
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">用户自定义类加载器（Custom ClassLoader）</font>**

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1.2 类加载器的必要性</font>
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">类加载器的核心价值体现在：</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">隔离性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：不同加载器加载的类相互不可见</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">灵活性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：支持动态加载、热部署等特性</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：防止核心类被篡改（如java.lang.String）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">多样性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：支持从非标准来源加载类（如网络、加密文件）</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1.3 命名空间</font>
![]({{ '/assets/img/图解JVM/17/2命名空间.png' | prepend: '' }})
![](.\img\图解JVM\17\2命名空间.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键点：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">每个类加载器拥有独立的命名空间</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不同命名空间的类默认互不可见</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">唯一性判断标准：全限定名 + 类加载器实例</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1.4 类加载机制的基本特征</font>
![]({{ '/assets/img/图解JVM/17/3类加载机制的基本特征.png' | prepend: '' }})
![](.\img\图解JVM\17\3类加载机制的基本特征.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">三大核心特征：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">全盘委托</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：优先委派父加载器</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">缓存机制</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：已加载类直接返回</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">防止重复</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：确保类唯一性</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1.5 类加载器之间的关系</font>
![]({{ '/assets/img/图解JVM/17/4类加载器之间的关系.png' | prepend: '' }})
![](.\img\图解JVM\17\4类加载器之间的关系.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">层次结构特点：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父子关系通过组合（非继承）实现</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Bootstrap是顶级父加载器（由C++实现）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">自定义加载器默认父级是AppClassLoader</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">形成树状而非简单的链式结构</font>

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2. 类的加载器分类</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2.1 引导类加载器（Bootstrap ClassLoader）</font>
![]({{ '/assets/img/图解JVM/17/5引导类加载器.png' | prepend: '' }})
![](.\img\图解JVM\17\5引导类加载器.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">核心特征：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">唯一没有父加载器的类加载器</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">加载路径：<JAVA_HOME>/lib目录下的核心类库</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">无法通过Java代码直接获取实例（返回null）</font>

```java
// 示例：获取String类的加载器
ClassLoader stringClassLoader = String.class.getClassLoader();
System.out.println(stringClassLoader); // 输出null
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2.2 扩展类加载器（Extension ClassLoader）</font>
![]({{ '/assets/img/图解JVM/17/6扩展类加载器.png' | prepend: '' }})
![](.\img\图解JVM\17\6扩展类加载器.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键细节：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父加载器是Bootstrap ClassLoader</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">加载路径：<JAVA_HOME>/lib/ext目录</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对应Java类：sun.misc.Launcher$ExtClassLoader</font>

```java
// 获取扩展类加载器
ClassLoader extClassLoader = ClassLoader.getSystemClassLoader().getParent();
System.out.println(extClassLoader); 
// 输出 sun.misc.Launcher$ExtClassLoader@xxxxxx
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2.3 系统类加载器（Application ClassLoader）</font>
![]({{ '/assets/img/图解JVM/17/7系统类加载器.png' | prepend: '' }})
![](.\img\图解JVM\17\7系统类加载器.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">主要特点：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父加载器是ExtClassLoader</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">加载路径：当前应用的classpath</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对应Java类：sun.misc.Launcher$AppClassLoader</font>

```java
// 获取系统类加载器
ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();
System.out.println(appClassLoader);
// 输出 sun.misc.Launcher$AppClassLoader@xxxxxx
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2.4 用户自定义类加载器</font>
```java
public class MyClassLoader extends ClassLoader {
    private String classPath;

    @Override
    protected Class<?> findClass(String name) {
        byte[] classData = loadClassData(name);
        return defineClass(name, classData, 0, classData.length);
    }

    private byte[] loadClassData(String className) {
        // 实现自定义加载逻辑...
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">自定义场景：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">热部署实现</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">加密字节码保护</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">模块化加载</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">多版本共存</font>

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3. 测试不同的类的加载器</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3.1 核心类库测试</font>
![]({{ '/assets/img/图解JVM/17/8核心类库测试.png' | prepend: '' }})
![](.\img\图解JVM\17\8核心类库测试.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">测试代码：</font>

```java
public class ClassLoaderTest {
    public static void main(String[] args) {
        printClassLoader("java.lang.String");
        printClassLoader("java.util.HashMap");
        printClassLoader("java.sql.DriverManager");
    }

    private static void printClassLoader(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            System.out.println(className + " 加载器: " 
                               + clazz.getClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">运行结果：</font>

```markdown
java.lang.String 加载器: null
java.util.HashMap 加载器: null 
java.sql.DriverManager 加载器: null
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">结论验证：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">所有核心类库均由BootstrapClassLoader加载</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">显示null是因为BootstrapClassLoader由C++实现，无法在Java层获取引用</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3.2 扩展类库测试</font>
![]({{ '/assets/img/图解JVM/17/9扩展类库测试.png' | prepend: '' }})
![](.\img\图解JVM\17\9扩展类库测试.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">测试步骤：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">找到JRE扩展目录（示例路径：</font>`<font style="background-color:rgb(252, 252, 252);">$JAVA_HOME/jre/lib/ext</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">查看dnsns.jar中的DNSNameService类</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">执行测试代码：</font>

```java
printClassLoader("sun.net.spi.nameservice.dns.DNSNameService");
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">运行结果：</font>

```markdown
sun.net.spi.nameservice.dns.DNSNameService 加载器: 
sun.misc.Launcher$ExtClassLoader@4eec7777
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键发现：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">扩展目录中的类由ExtClassLoader加载</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父加载器链：ExtClassLoader → BootstrapClassLoader</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3.3 应用类库测试</font>
![]({{ '/assets/img/图解JVM/17/10应用类库测试.png' | prepend: '' }})
![](.\img\图解JVM\17\10应用类库测试.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">测试代码：</font>

```java
public class MyApplicationClass {
    public static void main(String[] args) {
        // 测试自定义类
        printClassLoader("com.example.MyService");
        // 测试第三方库
        printClassLoader("org.apache.commons.lang3.StringUtils");
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">运行结果示例：</font>

```markdown
com.example.MyService 加载器: sun.misc.Launcher$AppClassLoader@18b4aac2
org.apache.commons.lang3.StringUtils 加载器: sun.misc.Launcher$AppClassLoader@18b4aac2
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">重要结论：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">所有classpath中的类（包括第三方JAR）都由AppClassLoader加载</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父加载器委托机制保证核心类不会被重复加载</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3.4 自定义类加载测试</font>
![]({{ '/assets/img/图解JVM/17/11自定义类加载测试.png' | prepend: '' }})
![](.\img\图解JVM\17\11自定义类加载测试.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">测试代码示例：</font>

```java
public class CustomLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader customLoader = new MyClassLoader();
        Class<?> clazz = customLoader.loadClass("com.example.Demo");
        System.out.println("自定义类加载器: " + clazz.getClassLoader());
    }
}

class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) {
        // 实现自定义加载逻辑
        byte[] bytes = loadClassData(name);
        return defineClass(name, bytes, 0, bytes.length);
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型输出：</font>

```markdown
自定义类加载器: MyClassLoader@6d06d69c
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">核心要点：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">自定义加载器打破双亲委派时需要重写loadClass方法</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">标准实现应该遵循双亲委派模型（重写findClass）</font>

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4. ClassLoader源码解析</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4.1 ClassLoader的主要方法</font>
![]({{ '/assets/img/图解JVM/17/12ClassLoader的主要方法.png' | prepend: '' }})
![](.\img\图解JVM\17\12ClassLoader的主要方法.png)

#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">核心方法源码解析：</font>
1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">loadClass() 双亲委派实现</font>**

```java
protected Class<?> loadClass(String name, boolean resolve) 
throws ClassNotFoundException {

    synchronized (getClassLoadingLock(name)) {
        // 1.检查是否已加载
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                // 2.递归调用父加载器
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器无法完成加载
            }

            if (c == null) {
                // 3.调用findClass自行加载
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">findClass() 模板方法</font>**

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">defineClass() 类定义核心</font>**

```java
protected final Class<?> defineClass(byte[] b, int off, int len)
throws ClassFormatError {
    return defineClass(null, b, off, len, null);
}
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4.2 SecureClassLoader与URLClassLoader</font>
![]({{ '/assets/img/图解JVM/17/13SecureClassLoader与URLClassLoader.png' | prepend: '' }})
![](.\img\图解JVM\17\13SecureClassLoader与URLClassLoader.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键设计：</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">SecureClassLoader</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 添加了权限控制</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">URLClassLoader</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 实现从URL路径加载类</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Ext/AppClassLoader</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 都是URLClassLoader的子类</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4.3 ExtClassLoader与AppClassLoader</font>
```java
// Launcher.java片段
static class ExtClassLoader extends URLClassLoader {
    public static ExtClassLoader getExtClassLoader() throws IOException {
        File[] dirs = getExtDirs();
        return new ExtClassLoader(dirs);
    }
}

static class AppClassLoader extends URLClassLoader {
    AppClassLoader(URL[] urls, ClassLoader parent) {
        super(urls, parent);
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键区别：</font>

| **<font style="background-color:rgb(252, 252, 252);">特性</font>** | **<font style="background-color:rgb(252, 252, 252);">ExtClassLoader</font>** | **<font style="background-color:rgb(252, 252, 252);">AppClassLoader</font>** |
| :---: | :---: | :---: |
| <font style="background-color:rgb(252, 252, 252);">加载路径</font> | <font style="background-color:rgb(252, 252, 252);">jre/lib/ext/*.jar</font> | <font style="background-color:rgb(252, 252, 252);">classpath路径</font> |
| <font style="background-color:rgb(252, 252, 252);">父加载器</font> | <font style="background-color:rgb(252, 252, 252);">BootstrapClassLoader</font> | <font style="background-color:rgb(252, 252, 252);">ExtClassLoader</font> |
| <font style="background-color:rgb(252, 252, 252);">实现类</font> | <font style="background-color:rgb(252, 252, 252);">sun.misc.Launcher$ExtClassLoader</font> | <font style="background-color:rgb(252, 252, 252);">sun.misc.Launcher$AppClassLoader</font> |


### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4.4 Class.forName()与ClassLoader.loadClass()</font>
![]({{ '/assets/img/图解JVM/17/14forNameAndloadClass.png' | prepend: '' }})
![](.\img\图解JVM\17\14forNameAndloadClass.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">代码对比：</font>

```java
// 默认执行初始化
Class.forName("com.example.Demo");

// 等效代码
Class.forName("com.example.Demo", true, currentClassLoader);

// 不执行初始化
classLoader.loadClass("com.example.Demo", false);
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键差异表：</font>

| **<font style="background-color:rgb(252, 252, 252);">特性</font>** | **<font style="background-color:rgb(252, 252, 252);">Class.forName()</font>** | **<font style="background-color:rgb(252, 252, 252);">ClassLoader.loadClass()</font>** |
| :---: | :---: | :---: |
| <font style="background-color:rgb(252, 252, 252);">初始化触发</font> | <font style="background-color:rgb(252, 252, 252);">默认触发</font> | <font style="background-color:rgb(252, 252, 252);">默认不触发</font> |
| <font style="background-color:rgb(252, 252, 252);">异常处理</font> | <font style="background-color:rgb(252, 252, 252);">抛出ClassNotFoundException</font> | <font style="background-color:rgb(252, 252, 252);">需要手动处理异常</font> |
| <font style="background-color:rgb(252, 252, 252);">使用场景</font> | <font style="background-color:rgb(252, 252, 252);">加载驱动类等需要初始化的场景</font> | <font style="background-color:rgb(252, 252, 252);">类结构分析等不需要初始化的场景</font> |


## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">5. 双亲委派模型</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">5.1 定义与本质</font>
![]({{ '/assets/img/图解JVM/17/15双亲委派模型.png' | prepend: '' }})
![](.\img\图解JVM\17\15双亲委派模型.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">本质特征：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">层级过滤机制</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：加载请求逐级过滤</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">优先权原则</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：父加载器优先尝试</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全屏障</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：防止核心类被篡改</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">类隔离基础</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：不同层级加载器形成隔离空间</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">常见误区：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">父加载器不是继承关系，而是组合关系</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不是严格的"双亲"，而是单亲委派链</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">BootstrapClassLoader不参与Java层次结构</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">5.2 优势与劣势</font>
![]({{ '/assets/img/图解JVM/17/16双亲委派模型优势分析.png' | prepend: '' }})
![](.\img\图解JVM\17\16双亲委派模型优势分析.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">优势总结：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：防止篡改java.lang等核心类</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">高效性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：避免重复加载消耗资源</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">稳定性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：保证基础类行为一致</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">简单性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：形成明确的类查找路径</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">劣势分析表：</font>

| **<font style="background-color:rgb(252, 252, 252);">劣势点</font>** | **<font style="background-color:rgb(252, 252, 252);">具体表现</font>** | **<font style="background-color:rgb(252, 252, 252);">典型案例</font>** |
| :---: | :---: | :---: |
| <font style="background-color:rgb(252, 252, 252);">灵活性不足</font> | <font style="background-color:rgb(252, 252, 252);">无法实现热替换</font> | <font style="background-color:rgb(252, 252, 252);">Tomcat模块化加载</font> |
| <font style="background-color:rgb(252, 252, 252);">扩展性受限</font> | <font style="background-color:rgb(252, 252, 252);">无法加载不同版本库</font> | <font style="background-color:rgb(252, 252, 252);">OSGi模块系统</font> |
| <font style="background-color:rgb(252, 252, 252);">上下文隔离</font> | <font style="background-color:rgb(252, 252, 252);">SPI服务加载困难</font> | <font style="background-color:rgb(252, 252, 252);">JDBC驱动加载</font> |
| <font style="background-color:rgb(252, 252, 252);">性能损耗</font> | <font style="background-color:rgb(252, 252, 252);">多级委派增加调用链路</font> | <font style="background-color:rgb(252, 252, 252);">高频动态加载场景</font> |


### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">5.3 破坏双亲委派机制</font>
![]({{ '/assets/img/图解JVM/17/17破坏双亲委派机制.png' | prepend: '' }})
![](.\img\图解JVM\17\17破坏双亲委派机制.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">JDBC破坏案例解析：</font>

```java
// DriverManager静态代码块
static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
}

private static void loadInitialDrivers() {
    // 使用线程上下文类加载器
    ServiceLoader<Driver> loadedDrivers = 
    ServiceLoader.load(Driver.class);
    // 加载实现类...
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键破坏手段：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">线程上下文类加载器</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（Thread Context ClassLoader）</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">逆向委派</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：子加载器直接加载父加载器范围的类</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分层加载</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：不同加载器加载相同类</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">5.4 热替换的实现</font>
![]({{ '/assets/img/图解JVM/17/18热替换的实现.png' | prepend: '' }})
![](.\img\图解JVM\17\18热替换的实现.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">热替换实现代码框架：</font>

```java
public class HotSwap {
    private volatile Object serviceInstance;
    private ClassLoader currentLoader;

    public void init() throws Exception {
        File watchDir = new File("/hotswap");
        WatchService watcher = FileSystems.getDefault().newWatchService();
        watchDir.register(watcher, ENTRY_MODIFY);

        new Thread(() -> {
            while (true) {
                WatchKey key = watcher.take();
                reloadClass();
                key.reset();
            }
        }).start();
    }

    private void reloadClass() {
        ClassLoader newLoader = new HotClassLoader();
        Class<?> clazz = newLoader.loadClass("ServiceImpl");
        serviceInstance = clazz.newInstance();
        currentLoader = newLoader; // 切换引用
    }
}
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">热替换关键点：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用自定义类加载器重新加载</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">新旧类必须实现相同接口</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">需要妥善处理静态状态迁移</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">旧类需满足卸载条件（无实例、无引用）</font>

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">6. 沙箱安全机制</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">6.1 JDK1.0时期</font>
![]({{ '/assets/img/图解JVM/17/19JDK1.0时期.png' | prepend: '' }})
![](.\img\图解JVM\17\19JDK1.0时期.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">初始安全模型特点：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">非黑即白的二元安全模式</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">仅支持本地代码的完全信任</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">无细粒度权限控制</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通过类加载器实现基础隔离</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型限制：</font>

```java
// 沙箱中运行的代码会抛出SecurityException
System.setSecurityManager(new SecurityManager());
FileInputStream fis = new FileInputStream("/etc/passwd"); // 抛出异常
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">6.2 JDK1.1时期</font>
![]({{ '/assets/img/图解JVM/17/20JDK1.1时期.png' | prepend: '' }})
![](.\img\图解JVM\17\20JDK1.1时期.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键改进：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">引入可扩展的安全管理器</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">细粒度权限检查方法</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">支持代码签名验证</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实现策略文件雏形</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">权限配置文件示例（.java.policy）：</font>

```plain
policy


grant codeBase "http://example.com/-" {
    permission java.io.FilePermission "/tmp/*", "read";
    permission java.net.SocketPermission "*:80", "connect";
};
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">6.3 JDK1.2时期</font>
![]({{ '/assets/img/图解JVM/17/21JDK1.2时期.png' | prepend: '' }})
![](.\img\图解JVM\17\21JDK1.2时期.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全架构升级要点：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">引入保护域（ProtectionDomain）概念</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实现权限（Permission）对象体系</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">建立访问控制器（AccessController）</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">支持动态权限判断</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">访问控制流程：</font>

```java
AccessController.doPrivileged(new PrivilegedAction<Void>() {
    public Void run() {
        // 受信任代码块
        new File("/secret.txt").delete();
        return null;
    }
});
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">6.4 JDK1.6时期</font>
![]({{ '/assets/img/图解JVM/17/22JDK1.6时期.png' | prepend: '' }})
![](.\img\图解JVM\17\22JDK1.6时期.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">最终形态安全特性：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">支持主体（Principal）授权</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">增强的策略动态刷新能力</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">改进的权限继承机制</font>
4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">细粒度访问控制上下文</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全策略配置示例：</font>

```java
// 创建自定义权限
public class DatabasePermission extends BasicPermission {
    public DatabasePermission(String name) {
        super(name);
    }
}

// 策略文件配置
grant principal javax.security.auth.x500.X500Principal "CN=admin" {
    permission com.example.DatabasePermission "query";
};
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全机制执行流程：</font>

![]({{ '/assets/img/图解JVM/17/23安全机制执行流程.png' | prepend: '' }})
![](.\img\图解JVM\17\23安全机制执行流程.png)

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">7. 自定义类的加载器</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">7.1 为什么要自定义类加载器？</font>
![]({{ '/assets/img/图解JVM/17/24自定义类加载器应用场景.png' | prepend: '' }})
![](.\img\图解JVM\17\24自定义类加载器应用场景.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型应用场景分析：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">热部署/热更新</font>**

![]({{ '/assets/img/图解JVM/17/25热更新.png' | prepend: '' }})
![](.\img\图解JVM\17\25热更新.png)

2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">字节码加密保护</font>**

```java
public class SecureClassLoader extends ClassLoader {
    protected Class<?> findClass(String name) {
        byte[] encryptedBytes = loadEncryptedClass(name);
        byte[] decrypted = decrypt(encryptedBytes); // 自定义解密算法
        return defineClass(name, decrypted, 0, decrypted.length);
    }
}
```

3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">多版本共存</font>**

![]({{ '/assets/img/图解JVM/17/26多版本共存.png' | prepend: '' }})
![](.\img\图解JVM\17\26多版本共存.png)

4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">非标准来源加载</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">数据库存储的类字节码</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">网络动态传输的类文件</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">内存实时生成的字节码</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">7.2 实现方式</font>
#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">标准实现模板</font>
![]({{ '/assets/img/图解JVM/17/27标准实现模板.png' | prepend: '' }})
![](.\img\图解JVM\17\27标准实现模板.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分步实现指南：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">继承ClassLoader基类</font>**

```java
public class MyClassLoader extends ClassLoader {
    public MyClassLoader(ClassLoader parent) {
        super(parent); // 显式指定父加载器
    }
}
```

2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">重写findClass方法</font>**

```java
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
    byte[] classBytes = loadClassBytes(name);
    return defineClass(name, classBytes, 0, classBytes.length);
}
```

3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实现字节码加载</font>**

```java
private byte[] loadClassBytes(String className) {
String path = className.replace('.', '/') + ".class";
try (InputStream ins = new FileInputStream(path);
     ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
    int bufferSize = 4096;
    byte[] buffer = new byte[bufferSize];
    int bytesNumRead;
    while ((bytesNumRead = ins.read(buffer)) != -1) {
        baos.write(buffer, 0, bytesNumRead);
    }
    return baos.toByteArray();
} catch (IOException e) {
    throw new ClassNotFoundException(className, e);
}
}
```

4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">打破双亲委派（可选）</font>**

```java
@Override
protected Class<?> loadClass(String name, boolean resolve)
throws ClassNotFoundException {
    // 针对特定包名跳过双亲委派
    if (name.startsWith("com.example.special")) {
        return findClass(name);
    }
    return super.loadClass(name, resolve);
}
```

#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">线程上下文类加载器</font>
![]({{ '/assets/img/图解JVM/17/28线程上下文类加载器.png' | prepend: '' }})
![](.\img\图解JVM\17\28线程上下文类加载器.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用模式：</font>

```java
// 设置上下文类加载器
Thread.currentThread().setContextClassLoader(myClassLoader);

// 获取上下文类加载器
ClassLoader loader = Thread.currentThread().getContextClassLoader();
Class<?> clazz = loader.loadClass("com.example.Service");
```

#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型面试实现题</font>
**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">需求：实现热部署类加载器</font>**

```java
public class HotswapClassLoader extends ClassLoader {
    private String basePath;

    public HotswapClassLoader(String basePath) {
        super(ClassLoader.getSystemClassLoader().getParent());
        this.basePath = basePath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] data = loadClassData(name);
        return defineClass(name, data, 0, data.length);
    }

    private byte[] loadClassData(String name) {
        // 从指定路径加载最新字节码
        String path = basePath + name.replace('.', '/') + ".class";
        try (InputStream ins = new FileInputStream(path)) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int b;
            while ((b = ins.read()) != -1) {
                baos.write(b);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">8. Java9新特性</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">8.1 模块化系统对类加载的影响</font>
![]({{ '/assets/img/图解JVM/17/29模块化系统对类加载的影响.png' | prepend: '' }})
![](.\img\图解JVM\17\29模块化系统对类加载的影响.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">重大变化：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">引导类加载器可见性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：BootstrapClassLoader在Java层可见（仍由C++实现）</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">平台类加载器</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：替代原来的ExtClassLoader</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">模块化层次结构</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

![]({{ '/assets/img/图解JVM/17/30模块化层次结构.png' | prepend: '' }})
![](.\img\图解JVM\17\30模块化层次结构.png)

4. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">资源访问限制：模块需显式暴露资源</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">8.2 类加载器API变化</font>
```java
// 模块化后的类加载示例
ModuleLayer.Controller controller = ModuleLayer.defineModulesWithOneLoader(
    configuration,
    List.of(parentLayer), 
    ClassLoader.getSystemClassLoader()
);

Class<?> clazz = controller.layer().findLoader("com.module")
.loadClass("com.example.Service");
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">新增核心类：</font>

+ `<font style="background-color:rgb(252, 252, 252);">java.lang.Module</font>`
+ `<font style="background-color:rgb(252, 252, 252);">java.lang.ModuleLayer</font>`
+ `<font style="background-color:rgb(252, 252, 252);">java.lang.Configuration</font>`

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">8.3 兼容性处理</font>
![]({{ '/assets/img/图解JVM/17/31兼容性处理.png' | prepend: '' }})
![](.\img\图解JVM\17\31兼容性处理.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">迁移策略：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用</font>`<font style="background-color:rgb(252, 252, 252);">--add-exports</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">暴露内部API</font>
2. `<font style="background-color:rgb(252, 252, 252);">--add-opens</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">允许反射访问</font>
3. `<font style="background-color:rgb(252, 252, 252);">--patch-module</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">修补模块</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（第八部分内容结束，后续将进入"常见问题与解决方案"章节）</font>

---

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">9. 常见问题与解决方案</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">9.1 NoClassDefFoundError vs ClassNotFoundException</font>
![]({{ '/assets/img/图解JVM/17/32NoClassDefFoundError.png' | prepend: '' }})
![](.\img\图解JVM\17\32NoClassDefFoundError.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">解决方案：</font>

```java
// ClassNotFoundException处理示例
try {
    Class<?> clazz = Class.forName("com.example.MissingClass");
} catch (ClassNotFoundException e) {
    // 检查classpath配置
    // 验证依赖是否完整
    // 确认类名拼写
}

// NoClassDefFoundError预防措施
public class SafeInit {
    static {
        try {
            // 避免静态块抛出异常
            init();
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }
}
```

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">9.2 实现热替换的难点</font>
![]({{ '/assets/img/图解JVM/17/33实现热替换的难点.png' | prepend: '' }})
![](.\img\图解JVM\17\33实现热替换的难点.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">常见问题：</font>

1. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">静态状态迁移困难</font>
2. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">旧实例无法自动升级</font>
3. <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">资源句柄无法转移</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">解决方案：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用接口隔离实现</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通过代理模式切换实现</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">结合OSGi等成熟框架</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（第九部分内容结束，最后将呈现"高频面试问题与解答"）</font>

---

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">10. 高频面试问题与解答</font>
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">10.1 双亲委派机制的优势与不足</font>
**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">问题</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：请解释双亲委派模型的工作原理及其优缺点</font>

**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">解答</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1. </font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">工作原理</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（图示辅助理解）</font>

![]({{ '/assets/img/图解JVM/17/34工作原理.png' | prepend: '' }})
![](.\img\图解JVM\17\34工作原理.png)

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">三大优势</font>**
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">安全性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：防止核心类库被篡改</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">唯一性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：避免重复加载消耗内存</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">高效性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：父加载器缓存提升加载速度</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">主要缺陷</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">上下文隔离导致SPI加载困难</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">无法实现真正的热替换</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">模块化场景适应性差</font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">10.2 如何打破双亲委派机制</font>
**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">问题</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：列举三种打破双亲委派模型的场景及实现方式</font>

**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">解答</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1. </font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">线程上下文加载器</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

```java
// JDBC驱动加载案例
ClassLoader original = Thread.currentThread().getContextClassLoader();
try {
    Thread.currentThread().setContextClassLoader(customLoader);
    DriverManager.getConnection(url); // 驱动使用上下文加载器
} finally {
    Thread.currentThread().setContextClassLoader(original);
}
```

3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">OSGi模块化方案</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">每个Bundle使用独立类加载器</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">网状结构的类依赖关系</font>
1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Tomcat容器设计</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Web应用隔离：每个WAR使用独立加载器</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">共享库统一加载：/common目录</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">热部署实现：创建新加载器实例</font>

