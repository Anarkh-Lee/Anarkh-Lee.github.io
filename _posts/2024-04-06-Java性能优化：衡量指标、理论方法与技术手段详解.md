---
layout: post
title: 'Java性能优化：衡量指标、理论方法与技术手段详解'
date: 2024-04-06
author: Anarkh-Lee
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: Java





---

> 这篇文章主要详解了 Java 性能优化，包括衡量指标（如吞吐量、响应速度、并发量等）、理论方法（基准测试、木桶理论、Amdahl 定律）和技术手段（复用优化、结果集优化、高效实现、算法优化、计算优化、资源冲突优化、JVM 优化）等内容。

# 1. 衡量指标

**衡量指标有哪些？**

1. 性能指标
   1. 吞吐量
      1. QPS
      2. TPS
      3. HPS
   2. 响应速度
2. 响应时间
   1. 平均响应时间
      1. AVG
   2. 百分位数
      1. Top Percentile
3. 并发量
4. 秒开率
5. 正确性

## 1.1 吞吐量和响应速度

分布式的高并发应用并不能把单次请求作为判断依据，它往往是一个统计结果。其中**最常用的衡量指标**就是吞吐量和响应速度。



**QPS**：每秒查询的数量

**TPS**：每秒事务的数量

**HPS**：每秒HTTP请求数量



**响应速度**是串行执行的优化，通过执行步骤解决问题；

**吞吐量**是并行执行的优化，通过合理利用计算资源达到目标。



在高并发的互联网应用中，使用有限的硬件资源，在响应速度和吞吐量之间找到一个平衡点。

## 1.2 响应时间衡量

- 平均响应时间

**是最常用的指标**，指标能够体现服务接口的平均处理能力。它的本质是把所有的请求耗时加起来，然后除以请求的次数。

- 百分位数

![gitment]({{ '/assert/img/1.png' | prepend: site.baseurl }})

![]({{'/assert/img/1.png'}})

它能够反映出应用接口的整体响应情况。

在这些高稳定性系统中，目标就是要**干掉严重影响系统的长尾请求**。这部分接口性能数据的收集，采用更加详细的日志记录方式，而不仅仅靠指标。比如，将某个接口，耗时超过1s的入参及执行步骤，详细地输出在日志系统中。

## 1.3 并发量

- **并发量**是指系统同时能处理的请求数量，这个指标反映了系统的负载能力。
- 在高并发应用中，仅仅高吞吐是不够的，它还必须**同时能为多个用户提供服务**。

并发高时，会导致很严重的共享资源争用问题，需要减少资源冲突，以及长时间占用资源的行为。

- 针对于响应时间进行设计，一般来说是万能的。

因为响应时间减少，同一时间能够处理的请求必然会增加。

## 1.4 秒开率

APP启动速度

## 1.5 正确性

某个接口测试，出现返回速度超级快的情况，分析后得知事故原因：项目中使用了熔断。

# 2. 理论方法

性能优化的理论方法：

1. 基准测试
2. 木桶理论
3. Amdahl定律

## 2.1 木桶理论

- 组成系统的组件，在速度上是良莠不齐的。**系统的整体性能**，就取决于系统中最慢的组件。
- 比如：在数据库应用中，制约性能最严重的是落盘的I/O问题。硬盘是这个场景下的短板，首要的任务就是补齐这个短板。

## 2.2基准测试

- 并不是简单的性能测试，是用来**测试某个程序的最佳性能**。
- 应用接口往往在刚启动后都有短暂的超时
  - 在测试之前，对应用进行预热，消除JIT编译器等因素的影响
  - 在Java里就有一个组件，即JMH，就可以消除这些差异

# 3. 性能优化的技术手段 

性能优化一般分为7类技术手段

1. 复用优化
2. 结果集优化
3. 高效实现
4. 算法优化
5. 计算优化
6. 资源冲突优化
7. JVM优化

## 3.1 复用优化

谈到数据复用，首先想到的就是缓冲和缓存，两者意义是完全不同的。

- **缓冲（Buffer）**：常见于对数据的暂存，然后批量传输或者写入。多使用顺序方式，用来缓解不同设备之间频繁地、缓慢地随机写。
- **缓存（Cache）**：常见于对已读取数据的复用。通过将它们缓存在相对高速的区域，缓存主要针对的是读操作。

![](/assert/img/2png.png)

## 3.2 计算优化

1. **并行执行**

现在的CPU发展速度很快，绝大多数硬件，都是多核。要想加快某个任务的执行，最快最优的解决方式，就是让它并行执行。

**多机**

**多进程**

**多线程（java采用此方式）**

2. **变同步为异步**

通常涉及变成模型的改变。请求会一直阻塞，直到有成功，或者失败结果的返回。

虽然编程模型简单，但应对突发的、时间段倾斜的流量，问题就特别大，请求很容易失败。

3. **惰性加载**

使用一些常见的设计模式来优化业务，提高体验，比如单例模式、代理模式等。

比如在绘制Swing窗口时，如果要显示比较多的图片，就可以先加载一个占位符，然后通过后台线程慢慢加载所需要的资源，这就可以避免窗口的僵死。

# 3.3 结果集优化

1. XML的表现形式是非常好的，那为什么还有JSON呢？

一个重要的原因就是体积变小，传输效率和解析效率变高。

像**Google的Protobuf**，**体积更小，虽然可读性低，但在一些高并发场景下（如RPC），能够显著提高效率**，这是典型的对结果集的优化。

2. 像Nginx，一般都会开启GZIP压缩，使得传输的内容保持紧凑。客户端只需要一小部分计算能力，就可以方便解压。由于这个操作是分散的，所以性能损失是固定的。
3. 对于一些对时效性要求不高，但对处理能力有高要求的业务，要吸取缓冲区的经验，尽量减少网络连接的交互，采用批量处理的方式，增加处理速度。

注：可采用bitmap、位图等优化。

## 3.4 资源冲突优化

在平常的开发中，会涉及很多共享资源

- 单机的，比如一个HashMap
- 外部存储，比如一个数据库行
- 单个资源，比如Redis某个key的Setnx
- 多个资源的协调，比如事务、分布式事务等



按照**锁级别**，锁可分为**乐观锁**和**悲观锁**，**乐观锁在效率上更高**。

按照**锁类型**，锁又分为**公平锁**和**非公平锁**，在对任务的调度上，有一些细微的差别。



注：无锁模式下解决资源冲突是比较优雅的。

## 3.5 算法优化

算法能够显著提高复杂业务的性能

但在实际的业务中，往往都是变种

由于存储越来越便宜，在一些CPU非常紧张的业务中，往往**采用空间换取时间的方式**，来加快处理速度。

算法属于代码调优，代码调优涉及很多编码技巧。

有事对算法、数据结构的灵活使用，也是代码优化的一个重要内容。

比如常用的降低时间复杂度的方式，就有**递归、二分、排序、动态规划**等。

## 3.6 高效实现

在平时的编程中，尽量使用一些设计理念良好、性能优越的组件。

比如有了Netty，就不用再选择比较老的Mina组件。

而在设计系统时，从性能因素考虑，就不要选SOAP这样比较耗时的协议。

比如一个号的语法分析器（比如使用JavaCC），其效率会比正则表达式高很多。

注：适配器模式很重要，现有工具上抽象出一层来使用。

## 3.7 JVM优化

因为Java是运行在JVM虚拟机之上，它的诸多特性，就要受到JVM的制约。对JVM虚拟机进行优化，也能在一定程度上能够提升Java程序的性能。如果参数配置不当，甚至会造成OOM等比较严重的后果。

目前被广泛使用的垃圾回收期是G1，通过很少的参数配置，内存即可高效回收。

CMS垃圾回收期已经在Java14中被移除。





<iframe type="text/html" width="100%" height="385" src="http://www.youtube.com/embed/gfmjMWjn-Xg" frameborder="0"></iframe>